<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>MindForge</title>
    <script src="https://unpkg.com/vue@2.7.8/dist/vue.js"></script>
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css"
    />
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Montserrat:ital,wght@0,100..900;1,100..900&display=swap"
      rel="stylesheet"
    />
    <link rel="stylesheet" href="styles.css" />
    <link
      rel="apple-touch-icon"
      sizes="180x180"
      href="images/apple-touch-icon.png"
    />
    <link
      rel="icon"
      type="image/png"
      sizes="32x32"
      href="images/favicon-32x32.png"
    />
    <link
      rel="icon"
      type="image/png"
      sizes="16x16"
      href="images/favicon-16x16.png"
    />
    <link rel="manifest" href="images/site.webmanifest" />
  </head>

   <body>
    <div id="app">
      <header class="site-header">
        <div style="display: flex; align-items: center">
          <img
            class="logo"
            src="images/favicon-32x32.png"
            alt="Website Logo"
            class="logo"
          />
          <div style="margin-left: 10px">
            <div class="site-title">MindForge</div>
          </div>
        </div>
        <!--Navigation between main(product page) and Checkout Section-->
        <div class="top-actions">
          <div class="checkoutInfo">
            <button
              class="checkout-btn"
              @click="toggleCheckout"
              :title="cartItemCount === 0 ? 'Cart is empty, add items to proceed' : ''"
              :class="{'disabled-btn': cartItemCount === 0}"
            >
              <svg
                class="icon"
                stroke="currentColor"
                fill="none"
                stroke-width="2"
                viewBox="0 0 24 24"
                stroke-linecap="round"
                stroke-linejoin="round"
                height="1em"
                width="1em"
                xmlns="http://www.w3.org/2000/svg"
              >
                <circle cx="9" cy="21" r="1"></circle>
                <circle cx="20" cy="21" r="1"></circle>
                <path
                  d="M1 1h4l2.68 13.39a2 2 0 0 0 2 1.61h9.72a2 2 0 0 0 2-1.61L23 6H6"
                ></path>
              </svg>
              {{ view === 'checkout' ? 'Back to Products' : 'Checkout (' +
              cartItemCount + ')' }}
            </button>
          </div>
        </div>
      </header>

      <div v-if="message" :class="['message', 'message-' + messageType]">
        {{ message }}
      </div>

      <!-- PRODUCT PAGE(Lessons catalogue)-->
      <div v-if="view === 'products'">
        <h2 style="margin-bottom: 10px">Welcome to our lessons Catalogue</h2>
        <!-- Controls: search / sort / max -->
        <div class="controls">
          <h3>Search & Sort</h3>
          <div>
            <input
              v-model="searchQuery"
              @input="performSearch"
              placeholder="üîç Search by subject"
            />
          </div>

          <div
            style="display: flex; gap: 10px; margin-top: 8px; flex-wrap: wrap"
          >
            <div>
              <label>Sort By:</label>
              <select v-model="sortField" @change="applyFilters">
                <option value="">None</option>
                <option value="subject">Subject</option>
                <option value="price">Price</option>
                <option value="category">Category</option>
                <option value="spaces">spaces</option>
              </select>
            </div>

            <div>
              <label>Order:</label>
              <select v-model="sortOrder" @change="applyFilters">
                <option value="asc">Ascending</option>
                <option value="desc">Descending</option>
              </select>
            </div>

            <div>
              <label>Max Results:</label>
              <input
                type="number"
                v-model.number="maxResults"
                min="1"
                max="500"
                @change="applyFilters"
              />
            </div>

            <div style="align-self: end">
              <button @click="resetFilters" type="button">Reset Filters</button>
            </div>
          </div>

          <div style="margin-top: 10px; font-size: 13px; color: #555">
            Showing {{ displayProducts.length }} of {{ allProducts.length }}
            document(s)
            <span v-if="searchQuery">
              | Searching for: "{{ searchQuery }}"</span
            >
            <span v-if="sortField">
              | Sorted by: {{ sortField }} ({{ sortOrder }})</span
            >
          </div>
        </div>
        <div v-if="loading" class="loading">Loading...</div>

        <!-- Products grid (displayProducts) -->
        <div v-else class="products-grid" style="margin-top: 12px">
          <div
            v-for="product in displayProducts"
            :key="product._id || product.id"
            class="product-card"
          >
            <h3
              v-html="highlightMatch(product.subject || product.name || 'Unnamed')"
            ></h3>
            <img
              v-if="product.image"
              :src="product.image"
              :alt="product.subject"
              style="width: 100%; border-radius: 10px; max-height: 50%"
            />
            <p v-if="product.price" class="price">
              $ {{ (product.price || 0).toFixed(2) }}
            </p>
            <p
              v-if="product.description"
              v-html="highlightMatch(product.description)"
            ></p>
            <p
              v-if="product.category"
              class="category"
              style="font-size: 12px; color: #666"
              v-html="highlightMatch(product.category)"
            ></p>
            <p
              v-if="product.spaces !== undefined"
              class="spaces"
              style="font-size: 12px; color: #666"
            >
              spaces: {{ itemsLeft(product) }}
            </p>

            <div
              v-if="product.rating !== undefined && product.rating !== null"
              style="margin-top: 6px"
            >
              <span
                v-for="n in 5"
                :key="n"
                class="fa-star"
                :class="n <= product.rating ? 'fa-solid' : 'fa-regular'"
              ></span>
              <span style="font-size: 12px; color: #555"
                >({{ product.rating }}/5)</span
              >
            </div>

            <div style="display: flex; gap: 8px; margin-top: 10px">
              <!-- Add to cart button -->
              <button
                :disabled="!canAddToCart(product)"
                @click="addToCart(product)"
              >
                Add to Cart
              </button>
            </div>

            <div style="margin-top: 8px; font-size: 13px; color: #666">
              <span v-if="itemsLeft(product) === 0" style="color: #ef4444"
                >Sold out!</span
              >
              <span v-else-if="itemsLeft(product) <= 5"
                >Only {{ itemsLeft(product) }} left!</span
              >
              <span v-else>Available</span>
            </div>
          </div>
        </div>
        <div v-if="!loading && allProducts.length === 0" class="empty-state">
          No classes were found, try another subject.
        </div>
      </div>

      <!-- CHECKOUT Page -->
      <div v-if="view === 'checkout'" class="checkoutPage">
        <h2>Checkout</h2>

        <!-- Required Fields with Asterisks and Placeholders -->
        <div class="form-group">
          <label class="required">First Name</label>
          <input
            v-model.trim="order.firstName"
            placeholder="First Name *"
            :class="{ 'error': fieldErrors.firstName }"
            @blur="validateField('firstName')"
          />
          <div v-if="fieldErrors.firstName" class="error-message">
            {{ fieldErrors.firstName }}
          </div>
        </div>

        <div class="form-group">
          <label class="required">Last Name</label>
          <input
            v-model.trim="order.lastName"
            placeholder="Last Name *"
            :class="{ 'error': fieldErrors.lastName }"
            @blur="validateField('lastName')"
          />
          <div v-if="fieldErrors.lastName" class="error-message">
            {{ fieldErrors.lastName }}
          </div>
        </div>

        <div class="form-group">
          <label class="required">Phone Number</label>
          <input
            v-model.trim="order.phone"
            placeholder="Phone Number * (Numbers only)"
            :class="{ 'error': fieldErrors.phone }"
            @blur="validateField('phone')"
            @input="validateField('phone')"
          />
          <div v-if="fieldErrors.phone" class="error-message">
            {{ fieldErrors.phone }}
          </div>
        </div>

        <div class="form-group">
          <label>Address</label>
          <input v-model.trim="order.address" placeholder="Address" />
        </div>

        <div class="form-group">
          <label>City</label>
          <input v-model.trim="order.city" placeholder="City" />
        </div>

        <div class="form-group">
          <label>District</label>
          <select v-model="order.state">
            <option disabled value="">Select District</option>
            <option v-for="state in states" :key="state">{{ state }}</option>
          </select>
        </div>

        <h3>Order Summary</h3>
        <p><strong>First Name:</strong> {{ order.firstName }}</p>
        <p><strong>Last Name:</strong> {{ order.lastName }}</p>
        <p><strong>Address:</strong> {{ order.address }}</p>
        <p><strong>City:</strong> {{ order.city }}</p>
        <p><strong>District:</strong> {{ order.state }}</p>
        <p><strong>Shipping Method:</strong> {{ order.method }}</p>
        <p><strong>Gift:</strong> {{ order.gift }}</p>

        <h4>Cart Items</h4>
        <ul>
          <li v-for="item in cart" :key="item.id">
            {{ item.subject || 'Item' }} : {{ item.quantity || 0 }} √ó ${{
            (item.price || 0).toFixed(2) }}
          </li>
        </ul>

        <div style="margin: 15px 0">
          <button
            @click="showModal = true"
            style="
              background: #2196f3;
              color: white;
              padding: 8px 16px;
              border: none;
              border-radius: 4px;
            "
          >
            üìù Edit Cart Items
          </button>
        </div>
        <div style="display: flex; gap: 8px; margin-top: 8px">
          <button
            @click="submitOrder()"
            :disabled="!isCheckoutFormValid"
            class="submit-btn"
          >
            Submit Order
          </button>
        </div>
        <div v-if="orderSuccess" class="success-overlay">
          <div class="success-popup">
            <div class="success">
              <div class="flex">
                <div class="flex-shrink-0">
                  <svg
                    class="succes-svg"
                    xmlns="http://www.w3.org/2000/svg"
                    viewBox="0 0 20 20"
                    fill="currentColor"
                    aria-hidden="true"
                  >
                    <path
                      fill-rule="evenodd"
                      d="M10 18a8 8 0 100-16 8 8 0 000 16zm3.707-9.293a1 1 0 00-1.414-1.414L9 10.586 7.707 9.293a1 1 0 00-1.414 1.414l2 2a1 1 0 001.414 0l4-4z"
                      clip-rule="evenodd"
                    ></path>
                  </svg>
                </div>
                <div class="success-prompt-wrap">
                  <p class="success-prompt-heading">Order completed</p>
                  <div class="success-prompt-prompt">
                    <p>
                      Order Submitted successfully, thanks for shopping with us!
                    </p>
                  </div>
                  <div class="success-button-container">
                    <button
                      @click="dismissSuccess"
                      type="button"
                      class="success-button-secondary"
                    >
                      Dismiss
                    </button>
                  </div>
                </div>
              </div>
            </div>
          </div>
        </div>
          
          <!-- Edit Cart Modal (always controlled by showModal) -->
          <div v-if="showModal" class="modal">
            <div class="modal-content">
              <button class="modal-close" @click="showModal=false">√ó</button>

              <h3>Edit Your Cart</h3>

              <div class="modal-body">
                <!-- EMPTY cart message -->
                <div
                  v-if="!cart || cart.length === 0"
                  class="empty-cart"
                  style="padding: 20px; text-align: center"
                >
                  <p>
                    Your cart is empty ‚Äî nothing here yet.
                  </p>
                  <p >
                    Browse products and add items to your cart. Upon addition, you'll be able to edit quantities here.
                  </p>

                  <div>
                    <button
                      type="button"
                      @click="toggleProducts()"
                    >
                      Browse Products
                    </button>
                  </div>
                </div>

                <!-- NON-EMPTY cart listing -->
                <div v-else>
                  <div
                    v-for="(product, index) in cart"
                    :key="product.id || product._id"
                    class="cart-item"
                    >
                    

                    <h4>{{ product.subject || product.name || 'No subject' }}</h4>
                    <p>Price: ${{ (product.price || 0).toFixed(2) }}</p>

                    <div>
                      <label>Quantity:</label>
                      <input
                        type="number"
                        v-model.number="product.quantity"
                        :min="1"
                        :max="getMaxQuantity(product.id || product._id)"
                      />

                      <button
                        type="button"
                        @click="removeOneFromCart(index)"
                        
                      >
                        Remove 1
                      </button>

                      <button
                        type="button"
                        @click="addToCart(product, 1)"
                       >
                        Add 1
                      </button>
                    </div>

                    <p style="margin-top: 5px; font-weight: bold">
                      Subtotal: ${{ ((product.price || 0) * (product.quantity ||
                      1)).toFixed(2) }}
                    </p>
                  </div>
                </div>
              </div>

              <!-- modal footer (single Save / Close controls, shown for both empty & non-empty) -->
              <div
                >
                <div>
                  <h4 style="margin: 0">
                    Cart Total: ${{ cartTotal.toFixed(2) }}
                  </h4>
                </div>

                <div style="display: flex; gap: 10px">
                  <!-- Save is disabled when there are no items -->
                  <button
                    type="button"
                    @click="closeModal()"
                    :disabled="!cart || cart.length === 0"
                    >
                    Save Changes
                  </button>
                </div>
              </div>
            </div>
          </div>
      </div>
    </div>
    <!--Script for Vue.js app-->
    <script>
      new Vue({
        el: "#app",
        data() {
          return {
            // UI
            view: "products",
            message: "",
            messageType: "",
            messageTimer: null,
            loading: false,
            fieldErrors: { firstName: "", lastName: "", phone: "" },

            // orders
            cart: [],
            saving: false,
            submittingOrder: false,
            deleting: false,
            modalMessage: "",
            orderSuccess: false,

            // API
            API_BASE: "https://project-cw-backend-apirest.onrender.com",
            collectionName: "lessons",

            // Products
            allProducts: [],
            displayProducts: [],

            // product form
            productForm: {
              subject: "",
              price: null,
              description: "",
              category: "",
              spaces: null,
              image: "",
              rating: null,
            },
            editMode: false,
            editingId: null,

            // search & sort
            searchQuery: "",
            sortField: "",
            sortOrder: "asc",
            maxResults: 10,

            sortKey: "price",
            sortAscending: true,
            productsToShow: 6,
            order: {
              firstName: "",
              lastName: "",
              phone: "",
              address: "",
              city: "",
              state: "",
              method: "Home",
              gift: "Do not send as Gift",
            },
            states: ["State 1", "State 2", "State 3", "State 4"],
            showModal: false,
          };
        },
        created() {
          this.fetchLessons();
        },
        computed: {
          cartItemCount() {
            return this.cart.reduce((sum, it) => sum + (it.quantity || 0), 0);
          },
          cartTotal() {
            return this.cart.reduce(
              (sum, it) => sum + (it.quantity || 0) * (it.price || 0),
              0
            );
          },
          // expose checkout validity as computed so template can bind :disabled="!isCheckoutFormValid"
          isCheckoutFormValid() {
            return this.validateCheckout();
          },
        },

        methods: {
          openEditModal() {
            this.showModal = true;
            this.selectedProduct = null; // no product selected yet
          },

          getMaxQuantity(productId) {
            const product = this.allProducts.find(
              (p) => (p._id || p.id) === productId
            );
            return product ? this.itemsLeft(product) : 1;
          },

          toggleProducts() {
            this.view = "products";
            window.scrollTo(0, 0);
            this.fetchLessons();
          },

          validateCheckout() {
            return (
              !!this.order.firstName &&
              !!this.order.lastName &&
              /^\d{7,15}$/.test(String(this.order.phone || ""))
            );
          },

          toggleCheckout() {
            if (this.cartItemCount === 0 && this.view !== "checkout") {
              this.showMessage(
                "Cart is empty. Please add items to cart before proceeding.",
                "error"
              );
              return;
            }
            this.view = this.view === "checkout" ? "products" : "checkout";
            window.scrollTo(0, 0);
          },

        //Simple methods which returns the lessons collection
          async fetchLessons() {
            this.loading = true;
            this.allProducts = [];
            this.displayProducts = [];
            try {
              const resp = await fetch(
                `${this.API_BASE}/lessons`
              );
              if (!resp.ok) throw new Error(`HTTP ${resp.status}`);
              const data = await resp.json();
              this.allProducts = Array.isArray(data) ? data : [];
              this.applyFilters();
              this.showMessage(
                `Loaded ${this.allProducts.length} document(s).`,
                "success"
              );
            } catch (err) {
              this.showMessage("API Unavailable.", "info");
            } finally {
              this.loading = false;
            }
          },

          //Performing search. Query fetched in front-end, but search logic done in baackend. Afterwards, results are displayed in front-end.
          //Dynamic Searching through subject  
          async performSearch() {
            if (this.searchQuery.trim() === "") {
              console.log("performSearch: empty query -> fetching collection");
              return this.fetchLessons();
            }
            try {
              const url = `${this.API_BASE}/search?query=${encodeURIComponent(
                this.searchQuery.trim()
              )}`;
              const response = await fetch(url);
              if (!response.ok) {
                const errJson = await response.json().catch(() => null);
                throw new Error(
                  errJson && errJson.error
                    ? errJson.error
                    : `HTTP: ${response.status}`
                );
              }
              const data = await response.json();
              this.allProducts = Array.isArray(data) ? data : [data];
              this.applyFilters();
            } catch (error) {
              console.error("Error performing search:", error);
              this.showMessage("Search failed, displaying all Courses");
              this.fetchLessons();
            }
          },

          //sorting Logic. Completely handled in front-end
          applyFilters() {
            let results = [...this.allProducts];
            if (this.sortField) {
              results.sort((a, b) => {
                let aVal = a[this.sortField];
                let bVal = b[this.sortField];
                if (aVal === undefined || aVal === null) aVal = "";
                if (bVal === undefined || bVal === null) bVal = "";
                if (typeof aVal === "string") aVal = aVal.toLowerCase();
                if (typeof bVal === "string") bVal = bVal.toLowerCase();
                if (this.sortOrder === "asc") {
                  return aVal > bVal ? 1 : aVal < bVal ? -1 : 0;
                } else {
                  return aVal < bVal ? 1 : aVal > bVal ? -1 : 0;
                }
              });
            }
            results = results.slice(0, this.maxResults || 10);
            this.displayProducts = results;
          },

          //clear all filters after click on reset button
          async resetFilters() {
            this.searchQuery = "";
            this.sortField = "";
            this.sortOrder = "asc";
            this.maxResults = 10;
            await this.performSearch();
          },

          highlightMatch(text) {
            if (!this.searchQuery || !text) return text;
            const q = this.searchQuery.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
            const regex = new RegExp("(" + q + ")", "gi");
            return text
              .toString()
              .replace(regex, '<span class="highlight">$1</span>');
          },

          //For any message shown(error/success)
          showMessage(text, type) {
            console.log("showMessage called:", text, type);

            // Clear any existing timer
            if (this.messageTimer) {
              clearTimeout(this.messageTimer);
              this.messageTimer = null;
            }

            // Set new message
            this.message = text;
            this.messageType = type;

            // Auto-clear after 4 seconds
            this.messageTimer = setTimeout(() => {
              this.clearMessage();
              this.messageTimer = null;
            }, 4000);
          },
          clearMessage() {
            this.message = "";
            this.messageType = "";
          },

          // Submitting and saving an order onclick
          //Backend routes accept customer Information, items in cart and total(count and amount) from order
          async submitOrder() {
            if (this.submittingOrder) return;
            this.submittingOrder = true;

            try {
              if (!this.validateCheckout()) {
                alert("Please fix the errors", "error");
                return;
              }

              const customer = {
                firstName: this.order.firstName.trim(),
                lastName: this.order.lastName.trim(),
                phone: this.order.phone.trim(),
                address: this.order.address.trim(),
                city: this.order.city.trim(),
                state: this.order.state.trim(),
                method: this.order.method,
                gift: this.order.gift,
              };

              const payload = {
                customer,
                items: this.cart,
                itemCount: this.cartItemCount,
                total: this.cartTotal,
              };

              const resp = await fetch(`${this.API_BASE}/orders`, {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify(payload),
              });

              await this.updateProductspacess();

              if (!resp.ok) throw new Error(`HTTP ${resp.status}`);

              this.orderSuccess = true;
            } catch (err) {
              alert("Order failed: " + err.message, "error");
            } finally {
              this.submittingOrder = false;
            }
          },

          resetAfterOrder() {
            // Clear everything after successful order
            this.cart = [];
            this.showEditModal = false;
            this.showEditModal = false;

            this.order = {
              firstName: "",
              lastName: "",
              phone: "",
              address: "",
              city: "",
              state: "",
              method: "Home",
              gift: "Do not send as Gift",
            };

            this.view = "products";
          },

          dismissSuccess() {
            this.orderSuccess = false;
            this.toggleProducts();
            this.resetAfterOrder();
          },
          // Update product spacess after each buy
          async updateProductspacess() {
            try {
              for (const cartItem of this.cart) {
                const productId = cartItem.id;
                const quantity = cartItem.quantity || 0;
                if (quantity <= 0) continue;
                const product = this.allProducts.find(
                  (p) => (p._id || p.id) === productId
                );
                if (!product) {
                  console.warn(
                    `Product ${productId} not found for spaces update`
                  );
                  continue;
                }
                const currentspaces =
                  product.spaces !== undefined
                    ? product.spaces
                    : product.availableInventory !== undefined
                    ? product.availableInventory
                    : Infinity;
                if (currentspaces === Infinity) continue;
                const newspaces = Math.max(0, currentspaces - quantity);
                try {
                  const payload = { spaces: newspaces };
                  const resp = await fetch(`${API_BASE}/${encodeURIComponent(this.collectionName)}/${productId}`,
                    {
                      method: "PUT",
                      headers: { "Content-Type": "application/json" },
                      body: JSON.stringify(payload),
                    }
                  );
                  if (!resp.ok) throw new Error(`HTTP ${resp.status}`);
                } catch (apiError) {
                  console.warn(
                    "API spaces update failed, updating locally:",
                    apiError
                  );
                  if (product.spaces !== undefined) product.spaces = newspaces;
                  else if (product.availableInventory !== undefined)
                    product.availableInventory = newspaces;
                }
                if (product.spaces !== undefined) product.spaces = newspaces;
                else if (product.availableInventory !== undefined)
                  product.availableInventory = newspaces;
              }
            } catch (error) {
              console.error("Error updating product spacess:", error);
              throw new Error(
                "Failed to update product spacess: " + error.message
              );
            }
          },

          // Delete order
          async deleteOrder() {
            if (this.deleting) return;
            if (
              !confirm(
                "Are you sure you want to delete this order? This cannot be undone."
              )
            )
              return;

            this.deleting = true;
            this.modalMessage = "Deleting...";
            try {
              // if final order exists, delete it
              if (this.lastOrderId) {
                const resp = await fetch(
                  `${this.API_BASE}/orders/${encodeURIComponent(
                    this.lastOrderId
                  )}`,
                  { method: "DELETE" }
                );
                if (!resp.ok) {
                  const e = await resp.json().catch(() => null);
                  throw new Error((e && e.error) || `HTTP ${resp.status}`);
                }
                this.showMessage("Order deleted", "success");
                this.lastOrderId = null;
              }
              // cleanup local
              this.cart = [];
              this.showModal = false;
              this.modalMessage = "";
            } catch (err) {
              console.error("deleteOrder error:", err);
              this.modalMessage = "Failed to delete: " + err.message;
              this.showMessage("Delete failed: " + err.message, "error");
            } finally {
              this.deleting = false;
            }
          },


          removeOneFromCart(index) {
            const item = this.cart[index];
            if (!item) return;
            const pid = item.id;
            // decrement quantity or remove
            if ((item.quantity || 0) > 1) {
              item.quantity -= 1;
            } else {
              this.cart.splice(index, 1);
            }
            // reflect availability back to displayed product
            const p = this.allProducts.find((x) => (x._id || x.id) === pid);
            if (p) {
              p.spaces = (Number(p.spaces) || 0) + 1;
            }
          },

          closeModal() {
            this.showModal = false;
            // ensure not left in edit mode
            this.modalEditMode = false;
            this.editableCartItems = [];
            this.editableCartBackup = [];
            this.modalMessage = "";
          },

          /* -------------------------
                   Cart helpers
                ------------------------- */
          //Every time addToCart is called, the quantity of this item in cart is incremented by One,
          addToCart(product, qty = 1) {
            if (!product) return;
            const pid = String(
              product._id ?? product.id ?? product.idNumber ?? ""
            ).trim();
            if (!pid) return;

            const existing = this.cart.find((c) => String(c.id) === pid);
            qty = Math.max(1, Math.floor(Number(qty) || 1));

            if (existing) {
              existing.quantity = (Number(existing.quantity) || 0) + qty;
            } else {
              this.cart.push({
                id: pid,
                subject: product.subject || product.name || "",
                price: Number(product.price || 0),
                image: product.image || "",
                quantity: qty,
              });
            }
            const display = this.allProducts.find(
              (p) => String(p._id ?? p.id) === pid
            );
            if (display && display.availableInventory !== undefined) {
              display.availableInventory = Math.max(
                0,
                (Number(display.availableInventory) || 0) - qty
              );
            }
          },

          //Number of items(lessons) in a cart
          cartCount(id) {
            const item = this.cart.find((c) => c.id === id);
            return item ? item.quantity : 0;
          },

          //Dependent on the number of spaces available. If no spaces available then user should not be able to buy more
          canAddToCart(product) {
            const spaces = Number(
              product.spaces !== undefined
                ? product.spaces
                : product.availableInventory !== undefined
                ? product.availableInventory
                : Infinity
            );
            return spaces > this.cartCount(product._id || product.id);
          },
          itemsLeft(product) {
            const spaces = Number(
              product.spaces !== undefined
                ? product.spaces
                : product.availableInventory !== undefined
                ? product.availableInventory
                : Infinity
            );
            return Math.max(
              0,
              spaces - this.cartCount(product._id || product.id)
            );
          },

          /*Validation for Submitting an order, those conditions have to be met
          firstName, LastName and phone number are required
          For Names, only letters and spaces are allowed
          For Phone No. it should be strictly 10 numerical characters*/
          validateField(fieldName) {
            const value = this.order[fieldName];
            switch (fieldName) {
              case "firstName":
              case "lastName":
                if (!value || !String(value).trim())
                  this.fieldErrors[fieldName] = "This field is required";
                else if (!/^[A-Za-z\s]+$/.test(value))
                  this.fieldErrors[fieldName] =
                    "Only letters and spaces allowed";
                else this.fieldErrors[fieldName] = "";
                break;
              case "phone":
                if (!value || !String(value).trim())
                  this.fieldErrors[fieldName] = "This field is required";
                else if (!/^\d+$/.test(String(value)))
                  this.fieldErrors[fieldName] = "Only numbers allowed";
                else if (String(value).length < 10)
                  this.fieldErrors[fieldName] =
                    "Phone must be at least 10 digits";
                else this.fieldErrors[fieldName] = "";
                break;
            }
          },
        },
      });
    </script>
  </body>
</html>
